# LeetCode 49 题解 - 高性能C++代码实现

给定一个字符串数组，目标是将所有的字母异位词组合在一起。字母异位词指的是由源单词的所有字母重新排列形成的新单词。本题解将引导你使用高性能的C++代码实现这一目标。

## 解题思路

### 排序字符串

一种直观的方法是对字符串进行排序，所有字母异位词排序后将产生相同的字符串。但是，排序字符串的效率并不高，其时间复杂度为 \(O(k \log k)\)，其中 \(k\) 是字符串的长度。考虑到只有有限的字母取值（26个小写字母或最多128个字符），我们可以考虑使用桶排序。

### 桶排序确定唯一特征

桶排序的思路是将字符串的字符分配到一个桶中，这样就可以得到一个能唯一标识“字母异位词”的桶。这个桶是一个`std::array<int,26>`类型，支持比较运算符，因此我们可以直接使用C++的`map`（红黑树实现），无需额外实现哈希函数。

### 通过交换律的概率实现（花里胡哨的思维拓展）

我们希望通过某些运算的交换律来确定字母异位词，即通过一个函数 \(f\) 读入一个字符串，并返回一个特征值，使得所有字母异位词的字符串返回相同的特征值。相同特征值的字符串不一定是相同的字母异位词，但大概率是。

以下是几种具有交换律的运算，可以用来构建这种特征：

1. **加法**：利用加法的交换律，通过对字符串中每个字符进行`sum += char - 'a'`操作来累加其值。
2. **乘法**：可以使用26个质数来唯一标识一个字符，或者使用质复数（实部和虚部都是整数的复数），甚至四元数，以表示更多的位数并减小质数的大小。
3. **异或**：具有交换律，可以用来构建特征。
4. **基于异或的二元运算**：将每个字符代表的数字转化为k进制数，然后按数位进行加法或乘法运算，可以模任意数 \(m\)。

最后，可以使用`std::map<feature, std::vector<std::vector<int>>>`来根据特征值组织字符串，使用链表来处理哈希冲突，需要依次比较以确定是否添加到相应位置上（假设不会有严重的哈希冲突，如果有，可以考虑增加一个特征）。